# Microservices

## What Is a Service?

A service is a piece of software, which basically provides functionality to other pieces of software within your system. It basically provides a service to other pieces of software. The other pieces of software could be anything from a website to a mobile app, or a desktop app, or even another service which uses another service in order to carry out a particular type of functionality. And, the service basically provides functionality to these applications. So, for example in the shopping website context, when a user places an order on the website, the website talks to the service, and the service actually carries out the creation, the update, the deletion, and the retrieval of what is from the database, so it provides functionality to the website application. And the communication between these software components and the service normally happen over a network using some kind of communication protocol. For example, a mobile app might communicate to a service via the internet. A system which uses a service or multiple services in this fashion is known to have a service oriented architecture, and this is normally abbreviated as S-O-A or SOA, and the main idea behind SOA is instead of using packet modules within each client application, I instead use a service to provide functionality to my client applications, and this allows me to have many client applications using the same functionality. And in the future, I can have newer or different types of clients connecting to the same service reusing that functionality. And as a software architecture, SOA has been successful. It allows us to scale up our software when demand increases, by enabling us to have a copy of the service on multiple servers, so when the traffic comes in, a load balancer will redirect that request to a specific instance of the service, and we can have multiple instances of the service, so when the demand increases, we just increase the number of instances of the service running across servers. We have already mentioned the fact that service oriented architecture provides reusability, reusability of functionality. So for example, the function to create an order on a website could be the same functionality which is triggered by a mobile app on our service. So, it's the same code creating an order for both the website and the mobile application. It allows us to reuse functionality. Another key characteristic of service oriented architecture is, is the idea of having standardized contracts or interfaces. When our client application called a service, it called a service by calling a method. The signature of that method normally doesn't change when the service changes, so we can upgrade our service without having to upgrade our clients, as long as the contract and the interface, either signature of the method doesn't change, we do not have to upgrade our clients when we upgrade our service. Anther key characteristic of a service is, is the fact that they are stateless. So, when a request comes in from a website to our service, that instance of the service does not have to remember the previous request from that specific customer, that specific client. It basically has all the information from the request, that it needs in order to retrieve all the data associated with previous request within the service, so a service does not have to remember the previous call the client has made to that particular instance of the service. It's stateless, therefore any instance of the service can honor any income request from a client, because it does not have to remember any previous interaction with any other instance of a service. Now that we know what a service is, and what the service oriented architecture is, we can start introducing the microservices architecture. The microservices architecture is basically an improved version of service oriented architecture, and therefore it shares all the key characteristics of the service oriented architecture, of scalability, reusability, and standardized contracts in interface for backwards compatibility, and the idea of having a service that stateless.

![Services](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Service.png?raw=true)

![Services 2](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Service_2.png?raw=true)

## Microservices

Microservices architecture is basically service oriented architecture done well. After years of doing service oriented architecture people have realized what service oriented architecture should be. And this is basically what microservices architecture is. It's an evolution of service oriented architecture. Microservices basically introduced a new set of additional design principles which teach you how to size a service correctly, because there was no guidance in the past on how to size a service and what to include in a service. Traditional service oriented architecture resulted in monolithic large services. And, because of the size of the service, these services became inefficient to scale up and to change in a reliable way. Smaller services, i. e. microservices. basically provide services which are more efficiently scalable, which are flexible. and we can provide high performance in the areas where performance is required. An application which is based on microservices architecture is normally an application which is powered by multiple microservices. And, each one of these microservices will provide a set of functions, a set of related functions to specific part of the application. A microservice normally provides a set of related functions to applications, to client applications, and client services, because the microservice normally has a single focus. It does one thing and it does it well. Microservice architecture also uses lightweight communication mechanism between clients and services, and service to service. The communication mechanism has to be lightweight and quick, because when you carry out a transaction within a microservices architecture system, the transaction will be a distributed transaction which is completed by multiple services. Therefore, the services need to communicate to each other in a quick and efficient way over the network. It needs to be a lightweight fast communication mechanism. The application interface for a microservice, either way you talk to a microservice, also needs to be technology agnostic. This basically means the service needs to use an open communication protocol so that it does not dictate the technology that the client application needs to use. And by using open communication protocols, for example like HTTP rest, we could easily have a. NET client application which talks to a Java based microservice. In a monolithic service, you're also likely to have a central database in order to share data between applications and services. In microservices architecture, each microservice has its own data storage. Another key characteristic of a microservice is that it is independently changeable. I can upgrade, enhance, or fix a specific microservice without changing any of the clients or any of the other services within the system. And because microservices are independently changeable, they also need to be independently deployable by modifying one microservice. I should be able to then deploy that change within my system independently from everything else, without deploying anything else. We've already mentioned the fact that when you make a transaction within a microservices architecture system, the transaction is most likely to be completed by multiple services, multiple services which are distributed, and therefore your transaction is also a distributed transaction. And because a microservices architecture system has so many moving parts, there's a need for centralized tooling for management of the microservices. You need something at all which will help you manage and see the health of your system, because there are so many moving parts. Okay, now let's have a look at a high-level architecture diagram for a microservices system. This is an example of a typical ecommerce system and as you can see, on the left hand side, a shopping website is running in the customer's browser. The browser connects to our shopping websites via the internet and our shopping website might be an ASP. NET MVC website which is running on the IIS. All the processing required for all the interactions with the website is actually carried out by a number of microservices which are running in the background. Each microservice has a single focus or a single set of related functions and each microservice also has its own data storage and it's also independently changeable and deployable. So for example, I could upgrade the orders service without upgrading any other part of my system. There might also be multiple instances for each type of microservice. For example, if the orders service is in demand, we might have several instances of the orders service in order to satisfy demand, and in order to direct a request from the shopping website to the correct instance of an orders service, we have an API Gateway. We will cover the API Gateway in more detail later on, but for now, think of it as something that manages and routes a request to the correct microservice within our system. So in this example, when the customer places an order, the shopping website might use multiple services and multiple functions within those services in order to satisfy the transaction. And this is why in a microservices architecture, a transaction is normally a distributed transaction, because the transaction is actually satisfied by multiple pieces of software, i. e., our microservices, in order to complete the transaction. And that's why the communication between these microservices needs to be super fast and lightweight in order to complete the transaction quickly. Throughout the rest of the course, you will see how design principles can be used to architect a microservices architecture like this.

![Microservices](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices.png?raw=true)

![Microservices 2](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices_2.png?raw=true)

## The Monolithic

This is basically the type of system that came before the microservices movement. These are large systems that almost do the opposite of what microservices are trying to achieve. Okay, so the typical monolithic system is basically your typical enterprise application, and this application might be in the form of a large website with all the modules packaged in together into one package, or it could be in the form of a service which talks to a website and the service itself is a large service with all the modules packaged together as one executable. The key characteristic is as you add stuff to your application, it keeps growing. There's no restriction in size. There's no division. There's always one package which basically contains everything, and therefore, you also end up with a large codebase, and because the codebase is so large, it might also take the team longer to develop new functionality within the application. It might be the code is so intertwined, that it's difficult to make a change without affecting other parts of the system, and therefore, testing takes longer. Deployment of a large system can also be challenging, because even for a small bug fix you are having to deploy a new version of the entire system, and therefore, that creates greater risk. And because there's so much code and so much intertwined code, there might be functionality in one of our modules within our overall package that might be useful to an external system, but because it's hidden within a monolithic application, it might not be exposed via the service, and you might have features in there which are not accessible. And because it's one large codebase, we're also stuck with one technology stack that might be a new technology. For example the promotions part of our system could do with using, but it's a new technology which is different to our current technologies stack, but because promotions is part of the overall package, we can't use that new technology within the promotions module. It makes our overall system less competitive, because we can't easily adopt new technologies which might give us a competitive edge. And because all the code is in one large package, we might also have high levels of coupling, which basically means if I change one part of the system, it might affect another part of the system, because the code is intertwined. And this kind of coupling might be present between modules, and it might also be present between different services. So, one large service might be intertwined with another large service, because if we change the signature of one service, it affects the other service. And because it is one package, if a part of the system fails, it could affect the whole system. For example, if the account processes gets stuck, it might affect the functionality of the overall service. It might degrade the performance of the overall service. Even scaling pu this service to meet demand is quite inefficient if let's say for example, the orders aspect of the system is in demand, we would have to create a copy of the whole package, of the whole service in order to scale up just the order section. This basically means we need to buy more powerful servers every time we need to scale up, because we are forced to scale the entire service up instead of just the part which needs scaling up. And because the footprint of the application is so large, we might actually need to buy powerful resource in order to run our entire application. We might have to place the service on a single server each time. When we do make a code change to the actual service, the time to compile the entire application will also be longer, because there's just more code, and there's more unit tests to run against the entire code base. The only one advantage a monolithic system has over a microservices system is the fact that you can run the entire code base on one machine, so when I'm developing and testing, I could probably replicate the entire environment on my machine, because it is just one thing to replicate and configure. Okay, here we have another example of a monolithic system. In this example we have a website application which packages in all the other modules from our system within one package. So, this could be an ASP. NET MVC site, where the website itself is the UI layer. In the business layer, you have your Accounts, Orders, Promotions, Inventory, and Products namespaces, which have classes related to each section. So, even though you're using namespaces to divide the code within our package, the code might be still quite intertwined, basically coupled, so changing one aspect might affect another aspect. So, change in Account might negatively affect Orders. For example you might change the signature of one of the methods in the Accounts class, and because you've changed that signature, you may have to reflect the code in one of the Orders classes, or in one of the Promotions classes. So, this means a change that was only actually relevant to the Accounts part of the system is now impacting other parts of the system. The application might be further coupled by having a one database. So for example, schema change within the database, for example changing the datatype on one column might result in several areas of the application requiring refactoring. You can probably see now why development times are longer with a monolithic system, and why deployment is such a challenge. There is just greater risk.

![The Monolithic Architecture](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Monolithic.png?raw=true)

## Emergence of Microservices

One of the reasons for the microservices architecture now is, is the need to respond to change quickly. The software market is really competitive nowadays. If your product can't provide a feature that's in demand, it will lose market share very quickly. And, this is where microservices can split a large system into parts, so we can upgrade and enhance individual parts in line with the market needs. So not only do we need to change part of a system quickly, we also need to change them in a reliable way in order to keep the market happy, and microservices provide this reliability by having your system in many parts, so if one part of the system breaks, it won't break the entire system. There is also need for business domain driven design. The architecture of our application needs to match the organization structure or the structure of the business functions within the organization. So, if for example Accounts are having a massive overhaul of their software, we can just change the account service without affecting any of the services related to other departments. There won't be any issues between departments if one department decides to change their software, because the software architecture matches the organization structure. Another reason why microservices architecture is now possible, is because we now have automated test tools. We've already seen that in a microservices architecture our transactions are distributed, and therefore a transaction will be processed by several services before it's complete. Therefore the integration between those services needs to be tested. And testing these microservices together manually might be quite a complex task, but the good news is these automated tests automatically test the integration between our microservices, and this is why microservices architecture is now possible, because we have automated test tools which test integration between services. Release and deployment of microservices can also be complex, because remember we now have multiple services, i. e. multiple pieces of software that we need to copy to servers or onto the cloud, and it might be that for each service type, we also have multiple instances that we need to operate at the same time. The good news is for release and deployment, we also have tools, centralized tools, which can carry out this function. Another reason why so many moving parts is no longer an issue any more, is the fact that we can host them using on demand technology. We can basically request things like virtual machines in order to host our microservices on demand. We basically no longer need to deploy our software to physical servers. We can instead just have a server which provides a cloud of virtual machines, and we can basically just clone these virtual machines and say deploy our microservices onto these virtual machines on demand, requesting them in software without having to do any physical work in order to configure and deploy the service onto a new host. On demand hosting is even now even more simpler. With cloud services on the internet, you can now basically spin up a machine in the cloud without even owning a physical box, and basically host your virtual machines, with your microservices running in them in a cloud service, which provides all the functional you need to manage and monitor you microservices. Another reason for the need to adopt microservices architecture is, is the need to adopt new technology, Because our system is now in several moving parts, we can easily change one part, i. e. a microservice from one technology stack to another technology stack in order to get a competitive edge. Another advancement in technology which makes microservices possible is the asynchronous communication technology. In our microservices architecture, when we use the distributed transactions, the distributed transactions might use several services. in order to complete. Using asynchronous communication, the distributed transaction does not have to wait for individual services to complete their tasks before it's complete. We will look at asynchronous communication technology in more detail in the technology module later on. Another reason why microservices architecture are possible now is the fact that we have simpler server side and client side technology. There are a number of technologies we can choose from, both at the server side and at the client site. And, there are many open communication protocols which allow the server side and client side technology stocks to work together quite happily. Okay, let's now highlight the key benefits of the microservices architecture. Okay, so one of the key benefits is that microservices have shorter development times, because the system is split up into smaller moving parts. You can work on a moving part individually. You can have teams working on different parts concurrently, and because microservices are small in size, and they have a single focus, and the team have less to worry about in terms of scope, they know the one thing they're working on has a certain scope, and there's no need to worry about the entire system, as long as they honor the contracts between services. And because these services are loosely coupled, developers can rework, change, and deploy individual components, without deploying or affecting the entire system, and therefore deployment is more reliable and faster. Shorter development times and reliable and faster deployment also enable frequent updates. As we've already briefly mentioned, frequent updates can give you a competitive edge in the marketplace. The microservices architecture also allows us to decouple changeable parts. For example if we know, UI for our system, our user interface for our system changes quite often, if it uses the microservices architecture, the UI is most likely decoupled from all the services in the background, and therefore you can change it independently from all the services. Microservices architecture also increases security. In a monolithic system, you might have one central database, with one system accessing that database, and therefore all you need to do is hack that one system in order to gain access to the data. In the microservices architecture each microservice has its own database, and each microservice can also have its own security mechanism, therefore making the data distributed, and making the data even more secure. Microservices architecture also offers you increased uptime, because when it comes to upgrading the system, you will probably deploy one microservice at the time without affecting rest of the system. And because the system is split up into business domains and business functions, when a problem arises, we can probably quickly identify which service is responsible for that specific business function, and therefore resolve the problem within that microservice. Microservices architecture also make the system highly scalable, and it gives the system better performance. When there's a specific part of the system which is in demand, we can just scale that specific part up instead of scaling the whole system up. So if for example the inventory service is in demand, we can create many instances of that microservice without duplicating the entire system. We can also give the ownership of a microservice to a particular development team, so that there's better ownership and knowledge about the microservice. We've already briefly mentioned that microservices allow us to use the right technology for specific parts in the system. And because each microservice is separate from the other microservice, they don't share databases, and they have their own codebase, you can easily have microservices being worked on concurrently by distributed teams. In the next section of the module, we'll start looking at the design principles that enable microservices, and enable these benefits that we get from microservices.

![Microservices - Why now?](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices_Why_Now.png?raw=true)

![Microservices - Benefits](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices_Benefits.png?raw=true)

## Design Principles Introduction

So, in order for your service to be a microservice, the service needs to have high cohesion, it needs to be autonomous, it must be business domain centric, and it must have resilience, and it also must be observable, and automation should also be used throughout the development process.

![Design Principles](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices_Desing_Principles.png?raw=true)

## High Cohesion

We are basically saying the microservice's content and functionality, in terms of input and output, must be coherent. It basically must have a single focus, and the thing it does, it should do well within that single focus. So for example you might have a service, a microservice, which has a single focus of calculating postage. So, all the inputs and outputs from this microservice are solely focused on something around to do with calculating postage. And this idea of a microservice having a single focus or a single responsibility, is actually taken from the solid coding principles. And the single responsibility principle basically states that a class can only change for one reason, and this same principle is applied to microservices, It's a useful principle, because it allows us to control the size of the service, and we will not accidentally create a monolithic service by attaching other behaviors into the microservice, which are not actually related. Our Postage service for example, only has one reason to change. It only changes if something to do with the postage calculation or the postage logic changes. We then enhance or upgrade our microservice with that new additional functionality. And the reason for change, i. e. the responsibility, normally represents a business function or a business domain. Our postage calculating microservice is a business function, and an Account service to do with the accounts department, might represent a business domain. High cohesion is also like the encapsulation principle from our old programming principles. We take all data and functionality that's related, and we package it into one package, which is the microservice, because the high cohesion principle controls the size of the microservice, and the scope of the contents of the microservice. The microservice is easily rewritable, as we are likely to have less of an attachment to a smaller codebase. And obviously, there will be fewer lines of code to rewrite because the microservice will be so small. And overall, if all our microservices have high cohesion, it makes our overall system highly scalable, flexible, and reliable. System is more scalable, because we can scale up individual microservices which represents a specific business function or a business domain which is in demand, instead of scaling up the whole system. And at the same time the system is more flexible, because we can change and upgrade or change the functionality of specific business functions or business domains within our system. And then we have reliability, because overall we are changing specific small parts within the system without affecting other parts within the system.

![High Cohesion](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices_High_Cohesion.png?raw=true)

## Autonomous

By autonomous we mean, a microservice should not be subject to change because of an external system it interacts with, or an external system that interacts with it. we are basically saying there should be loose coupling between the microservices and between the microservices and the clients that use the microservices. And by loose coupling we mean, a change to a microservice should not force other microservices to change or other clients to change. This means microservices must honor contracts and interfaces to other services and other clients, which basically means the way the input and output are formatted for a microservice should not change between versions, because that might break any other services trying to interact with that microservice, using those inputs and outputs. Like a website, a microservice should also be stateless. There should be no need to remember previous interactions that clients might of had with this service or other service instances in order to carry out the current request. And because microservices honor contracts and interfaces to other services and clients, they should be independently changeable, and independently deployable. They should just slot back into the system after a change or an enhancement even though it has a newer version than any of the other components within the system. This also ensures our service is always backwards compatible. Having clear defined contracts between services also means that microservices can be concurrently developed by several teams. Because there's a clear definition of the input and output of a microservice, separate teams can work on separate microservices. As long as they honor the contracts, development should go okay.

![Autonomous](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices_Autonomous.png?raw=true)

## Business Domain Centric

A microservice should also be business domain centric, and by this we mean that a service should represent a business function. For example, in the organization you might have an accounts department that has a lot of accounting software and accounting functionality. And this account department might end up having code which results in a microservice to do with accounting functionality. You might also have specific business functions, for example calculating postage which might also end up within a microservice as a microservice itself. The overall idea is, is to have a microservice represent a business function or a business domain, i. e. a part of the organization, because this helps scope the service and control the size of the service. This is an idea which is taken from domain driven design. You basically define a bounded context, which basically contains all the functionality which is related to a specific part of the business, to a business domain, or a business function. And you define the bounded context by defining boundaries and seams within the code. You basically highlight the areas where related functionality exist. So for example on our diagram on the left, you have code which is related to the accounts department and give code which is related to the orders department, and the contents within each section becomes the bounded context, and overall this will eventually become our microservice. There will be times when code relates to two different bounded contexts, and this is where we need to shuffle the code around, so the code ends up in the right place, where it makes sense and it belongs, in terms of business function or business domain. We need to aim for high cohesion, remember? Making our microservices business domain centric also makes our microservices responsive to business change, so as the business changes, or the organization changes, or functions within the business change, our microservices can change in the same way. Because our system is broken up into individual parts, which are business domain centric, we can also change those parts which relate to specific parts in the organization which are changing.

![Business Domain Centric](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices_Business_Domain_Centric.png?raw=true)

## Resilience

We basically need to embrace failure when it happens. Failure might be in the form of another service not responding to your service. or might be a connection line to another system which has going down, or it might be a third party system which fails to respond. Whatever the type of failure, our microservice needs to embrace that failure by degrading the functionality within our microservice, or by using default functionality. An example of degrading functionality might be a scenario where we have a user interface microservice which basically draws a HTML page for available orders and promotions, but for whatever reason, the Promotions microservice is down and fails to respond. So, our user interface microservice basically chooses to degrade that functionality, and it chooses not to display the promotions on the page. An example of default functionality might be, a postage microservice. If the postage microservice goes down and doesn't respond, and the Orders microservice relies on the Postage microservice, when it detects the fact that the Postage microservice is not responding, the Orders microservice might use a default postage rate for the order instead of retrieving one from the Postage microservice. Another way of making microservices more resilient is by having multiple instances of microservices, so they register themselves as they start up, and if any of them fail, they deregister themselves, so our system, or our load balancers, et cetera, are only ever a way of fully functioning microservices. We also need to be aware there are different types of failures. So for example that might be exceptions or errors within a microservice. There might be delays in replying to a request, and there might also be complete unavailability of microservice, and this is where we need to work out if we did need to degrade functionality, or if we need to default functionality. Failures are also not just limited to the software itself. You might have network failures. And remember, we're using distributed-transactions here, where one transaction might go across the network and use several services before it actually completes. And therefore again, we need to make our microservices resilient to network delays or unavailability. We also need to ensure that when our microservices are called, and the input they receive as part of their request, that we can validate that input. And, this might be input from services, or from clients. We need to ensure that our microservices are resilient and can validate incoming data, and they don't basically fall over, because they've received something in an incorrect format.

![Resilience](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices_Resilience.png?raw=true)

## Observable

We need a way to be able to observe our system's health in terms of system status, in terms of logs, i. e. activity currently happening in the system, and errors that are currently happening in the system. And, this type of monitoring and logging needs to be centralized, so that there's one place where we need to go to in order to view this information regarding the system's health. And, we need this level of monitoring and logging in a centralized place, because we now have distributed transactions. In order for a transaction to complete, it must go across the network and use several services. Therefore, knowing the health of the system is vital, and this kind of data would also be useful for quick problem solving. Because the whole system is distributed, and there's a lot going on, we need a quick way of working out where our potential problem possibly lies. And because we are also using automated tools for deployment, which means our deployment will be very quick, we also need a quick way of getting feedback in response to deployment, so if there are any issues we can clearly see from a centralized place. This data collected can also be used for capacity planning and also for scaling up of our system. So, when we can see that there's a clear demand somewhere within our system for a specific microservice, we can scale that area up. Orm when we know we've got let's say, 100 million customers going live soon, we can use this data to work out exactly how we can plan the capacity of our system in the future. We can also use this data to work out what parts of our system are actually used, and we can also build in some measures, in terms of logging in order to measure specific things which are related to the business, for example the number of sales on a daily basis. We can all log this to our central logging system, and view this from a centralized place.

![Observable](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices_Observable.png)

## Automation

We also need to feature automation in our microservice architecture, automation in the form of tools, for example tools to reduce testing. Automated testing will reduce the amount of time required for manual regression testing, and the time taken to test integration between services and clients, and also the time taken to set up test environments. Remember, in a microservices architecture, our system is made up of several moving parts, and therefore testing can be quite complex, and this is what we need testing tools to automate some of that testing. We need tools, automated testing tools, which gives quick feedback. So, as soon as I change a microservice and check that we have code in, into our sort control system, I want these test automation tools to provide me feedback on integration, to give me confidence that my change integrate with the entire system. And this type of testing, this type of automated testing whichs test for integration, is known as continuous integration. As well as automation tools to help with testing, we need automation tools to help with deployment, a tool which basically provides a pipeline to deployment. It gives our microservice a deployment release status, so when you check a change in, the test pass, and then the deployment status is at ready, then the tool knows that this build of the microservice is now ready for deployment. So, not only does this tool provide a pipeline, or the status for each deployable build of a microservice, it also provides a way of actually physically moving the build to the target machine, or the target cloud system, so the physical deployment of the software will be all automatic and therefore will be reliable, because it's preconfigured with the target, where the software needs to go, and it will be configured and tested once, and therefore it should work every time. The idea of using automation tools for deployment falls under a category called continuous deployment. So in order to have automation, we need to use continuous integration tools and continuous deployment tools, because in a microservices architecture, we have a system which is a distributed system and there are multiple instances of the services. This is a much more complex system and the way to organize across our system and you know with such a distributed system, manual integration testing would be too time-consuming and manual deployment will be too time-consuming and unreliable.

![Automation](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices_Automation.png?raw=true)
