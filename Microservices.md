# Microservices

## What Is a Service?

A service is a piece of software, which basically provides functionality to other pieces of software within your system. It basically provides a service to other pieces of software. The other pieces of software could be anything from a website to a mobile app, or a desktop app, or even another service which uses another service in order to carry out a particular type of functionality. And, the service basically provides functionality to these applications. So, for example in the shopping website context, when a user places an order on the website, the website talks to the service, and the service actually carries out the creation, the update, the deletion, and the retrieval of what is from the database, so it provides functionality to the website application. And the communication between these software components and the service normally happen over a network using some kind of communication protocol. For example, a mobile app might communicate to a service via the internet. A system which uses a service or multiple services in this fashion is known to have a service oriented architecture, and this is normally abbreviated as S-O-A or SOA, and the main idea behind SOA is instead of using packet modules within each client application, I instead use a service to provide functionality to my client applications, and this allows me to have many client applications using the same functionality. And in the future, I can have newer or different types of clients connecting to the same service reusing that functionality. And as a software architecture, SOA has been successful. It allows us to scale up our software when demand increases, by enabling us to have a copy of the service on multiple servers, so when the traffic comes in, a load balancer will redirect that request to a specific instance of the service, and we can have multiple instances of the service, so when the demand increases, we just increase the number of instances of the service running across servers. We have already mentioned the fact that service oriented architecture provides reusability, reusability of functionality. So for example, the function to create an order on a website could be the same functionality which is triggered by a mobile app on our service. So, it's the same code creating an order for both the website and the mobile application. It allows us to reuse functionality. Another key characteristic of service oriented architecture is, is the idea of having standardized contracts or interfaces. When our client application called a service, it called a service by calling a method. The signature of that method normally doesn't change when the service changes, so we can upgrade our service without having to upgrade our clients, as long as the contract and the interface, either signature of the method doesn't change, we do not have to upgrade our clients when we upgrade our service. Anther key characteristic of a service is, is the fact that they are stateless. So, when a request comes in from a website to our service, that instance of the service does not have to remember the previous request from that specific customer, that specific client. It basically has all the information from the request, that it needs in order to retrieve all the data associated with previous request within the service, so a service does not have to remember the previous call the client has made to that particular instance of the service. It's stateless, therefore any instance of the service can honor any income request from a client, because it does not have to remember any previous interaction with any other instance of a service. Now that we know what a service is, and what the service oriented architecture is, we can start introducing the microservices architecture. The microservices architecture is basically an improved version of service oriented architecture, and therefore it shares all the key characteristics of the service oriented architecture, of scalability, reusability, and standardized contracts in interface for backwards compatibility, and the idea of having a service that stateless.

![Services](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Service.png?raw=true)

![Services 2](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Service_2.png?raw=true)

## Microservices

Microservices architecture is basically service oriented architecture done well. After years of doing service oriented architecture people have realized what service oriented architecture should be. And this is basically what microservices architecture is. It's an evolution of service oriented architecture. Microservices basically introduced a new set of additional design principles which teach you how to size a service correctly, because there was no guidance in the past on how to size a service and what to include in a service. Traditional service oriented architecture resulted in monolithic large services. And, because of the size of the service, these services became inefficient to scale up and to change in a reliable way. Smaller services, i. e. microservices. basically provide services which are more efficiently scalable, which are flexible. and we can provide high performance in the areas where performance is required. An application which is based on microservices architecture is normally an application which is powered by multiple microservices. And, each one of these microservices will provide a set of functions, a set of related functions to specific part of the application. A microservice normally provides a set of related functions to applications, to client applications, and client services, because the microservice normally has a single focus. It does one thing and it does it well. Microservice architecture also uses lightweight communication mechanism between clients and services, and service to service. The communication mechanism has to be lightweight and quick, because when you carry out a transaction within a microservices architecture system, the transaction will be a distributed transaction which is completed by multiple services. Therefore, the services need to communicate to each other in a quick and efficient way over the network. It needs to be a lightweight fast communication mechanism. The application interface for a microservice, either way you talk to a microservice, also needs to be technology agnostic. This basically means the service needs to use an open communication protocol so that it does not dictate the technology that the client application needs to use. And by using open communication protocols, for example like HTTP rest, we could easily have a. NET client application which talks to a Java based microservice. In a monolithic service, you're also likely to have a central database in order to share data between applications and services. In microservices architecture, each microservice has its own data storage. Another key characteristic of a microservice is that it is independently changeable. I can upgrade, enhance, or fix a specific microservice without changing any of the clients or any of the other services within the system. And because microservices are independently changeable, they also need to be independently deployable by modifying one microservice. I should be able to then deploy that change within my system independently from everything else, without deploying anything else. We've already mentioned the fact that when you make a transaction within a microservices architecture system, the transaction is most likely to be completed by multiple services, multiple services which are distributed, and therefore your transaction is also a distributed transaction. And because a microservices architecture system has so many moving parts, there's a need for centralized tooling for management of the microservices. You need something at all which will help you manage and see the health of your system, because there are so many moving parts. Okay, now let's have a look at a high-level architecture diagram for a microservices system. This is an example of a typical ecommerce system and as you can see, on the left hand side, a shopping website is running in the customer's browser. The browser connects to our shopping websites via the internet and our shopping website might be an ASP. NET MVC website which is running on the IIS. All the processing required for all the interactions with the website is actually carried out by a number of microservices which are running in the background. Each microservice has a single focus or a single set of related functions and each microservice also has its own data storage and it's also independently changeable and deployable. So for example, I could upgrade the orders service without upgrading any other part of my system. There might also be multiple instances for each type of microservice. For example, if the orders service is in demand, we might have several instances of the orders service in order to satisfy demand, and in order to direct a request from the shopping website to the correct instance of an orders service, we have an API Gateway. We will cover the API Gateway in more detail later on, but for now, think of it as something that manages and routes a request to the correct microservice within our system. So in this example, when the customer places an order, the shopping website might use multiple services and multiple functions within those services in order to satisfy the transaction. And this is why in a microservices architecture, a transaction is normally a distributed transaction, because the transaction is actually satisfied by multiple pieces of software, i. e., our microservices, in order to complete the transaction. And that's why the communication between these microservices needs to be super fast and lightweight in order to complete the transaction quickly. Throughout the rest of the course, you will see how design principles can be used to architect a microservices architecture like this.

![Microservices](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices.png?raw=true)

![Microservices 2](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices_2.png?raw=true)

## The Monolithic

This is basically the type of system that came before the microservices movement. These are large systems that almost do the opposite of what microservices are trying to achieve. Okay, so the typical monolithic system is basically your typical enterprise application, and this application might be in the form of a large website with all the modules packaged in together into one package, or it could be in the form of a service which talks to a website and the service itself is a large service with all the modules packaged together as one executable. The key characteristic is as you add stuff to your application, it keeps growing. There's no restriction in size. There's no division. There's always one package which basically contains everything, and therefore, you also end up with a large codebase, and because the codebase is so large, it might also take the team longer to develop new functionality within the application. It might be the code is so intertwined, that it's difficult to make a change without affecting other parts of the system, and therefore, testing takes longer. Deployment of a large system can also be challenging, because even for a small bug fix you are having to deploy a new version of the entire system, and therefore, that creates greater risk. And because there's so much code and so much intertwined code, there might be functionality in one of our modules within our overall package that might be useful to an external system, but because it's hidden within a monolithic application, it might not be exposed via the service, and you might have features in there which are not accessible. And because it's one large codebase, we're also stuck with one technology stack that might be a new technology. For example the promotions part of our system could do with using, but it's a new technology which is different to our current technologies stack, but because promotions is part of the overall package, we can't use that new technology within the promotions module. It makes our overall system less competitive, because we can't easily adopt new technologies which might give us a competitive edge. And because all the code is in one large package, we might also have high levels of coupling, which basically means if I change one part of the system, it might affect another part of the system, because the code is intertwined. And this kind of coupling might be present between modules, and it might also be present between different services. So, one large service might be intertwined with another large service, because if we change the signature of one service, it affects the other service. And because it is one package, if a part of the system fails, it could affect the whole system. For example, if the account processes gets stuck, it might affect the functionality of the overall service. It might degrade the performance of the overall service. Even scaling pu this service to meet demand is quite inefficient if let's say for example, the orders aspect of the system is in demand, we would have to create a copy of the whole package, of the whole service in order to scale up just the order section. This basically means we need to buy more powerful servers every time we need to scale up, because we are forced to scale the entire service up instead of just the part which needs scaling up. And because the footprint of the application is so large, we might actually need to buy powerful resource in order to run our entire application. We might have to place the service on a single server each time. When we do make a code change to the actual service, the time to compile the entire application will also be longer, because there's just more code, and there's more unit tests to run against the entire code base. The only one advantage a monolithic system has over a microservices system is the fact that you can run the entire code base on one machine, so when I'm developing and testing, I could probably replicate the entire environment on my machine, because it is just one thing to replicate and configure. Okay, here we have another example of a monolithic system. In this example we have a website application which packages in all the other modules from our system within one package. So, this could be an ASP. NET MVC site, where the website itself is the UI layer. In the business layer, you have your Accounts, Orders, Promotions, Inventory, and Products namespaces, which have classes related to each section. So, even though you're using namespaces to divide the code within our package, the code might be still quite intertwined, basically coupled, so changing one aspect might affect another aspect. So, change in Account might negatively affect Orders. For example you might change the signature of one of the methods in the Accounts class, and because you've changed that signature, you may have to reflect the code in one of the Orders classes, or in one of the Promotions classes. So, this means a change that was only actually relevant to the Accounts part of the system is now impacting other parts of the system. The application might be further coupled by having a one database. So for example, schema change within the database, for example changing the datatype on one column might result in several areas of the application requiring refactoring. You can probably see now why development times are longer with a monolithic system, and why deployment is such a challenge. There is just greater risk.

![The Monolithic Architecture](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Monolithic.png?raw=true)

## Emergence of Microservices

One of the reasons for the microservices architecture now is, is the need to respond to change quickly. The software market is really competitive nowadays. If your product can't provide a feature that's in demand, it will lose market share very quickly. And, this is where microservices can split a large system into parts, so we can upgrade and enhance individual parts in line with the market needs. So not only do we need to change part of a system quickly, we also need to change them in a reliable way in order to keep the market happy, and microservices provide this reliability by having your system in many parts, so if one part of the system breaks, it won't break the entire system. There is also need for business domain driven design. The architecture of our application needs to match the organization structure or the structure of the business functions within the organization. So, if for example Accounts are having a massive overhaul of their software, we can just change the account service without affecting any of the services related to other departments. There won't be any issues between departments if one department decides to change their software, because the software architecture matches the organization structure. Another reason why microservices architecture is now possible, is because we now have automated test tools. We've already seen that in a microservices architecture our transactions are distributed, and therefore a transaction will be processed by several services before it's complete. Therefore the integration between those services needs to be tested. And testing these microservices together manually might be quite a complex task, but the good news is these automated tests automatically test the integration between our microservices, and this is why microservices architecture is now possible, because we have automated test tools which test integration between services. Release and deployment of microservices can also be complex, because remember we now have multiple services, i. e. multiple pieces of software that we need to copy to servers or onto the cloud, and it might be that for each service type, we also have multiple instances that we need to operate at the same time. The good news is for release and deployment, we also have tools, centralized tools, which can carry out this function. Another reason why so many moving parts is no longer an issue any more, is the fact that we can host them using on demand technology. We can basically request things like virtual machines in order to host our microservices on demand. We basically no longer need to deploy our software to physical servers. We can instead just have a server which provides a cloud of virtual machines, and we can basically just clone these virtual machines and say deploy our microservices onto these virtual machines on demand, requesting them in software without having to do any physical work in order to configure and deploy the service onto a new host. On demand hosting is even now even more simpler. With cloud services on the internet, you can now basically spin up a machine in the cloud without even owning a physical box, and basically host your virtual machines, with your microservices running in them in a cloud service, which provides all the functional you need to manage and monitor you microservices. Another reason for the need to adopt microservices architecture is, is the need to adopt new technology, Because our system is now in several moving parts, we can easily change one part, i. e. a microservice from one technology stack to another technology stack in order to get a competitive edge. Another advancement in technology which makes microservices possible is the asynchronous communication technology. In our microservices architecture, when we use the distributed transactions, the distributed transactions might use several services. in order to complete. Using asynchronous communication, the distributed transaction does not have to wait for individual services to complete their tasks before it's complete. We will look at asynchronous communication technology in more detail in the technology module later on. Another reason why microservices architecture are possible now is the fact that we have simpler server side and client side technology. There are a number of technologies we can choose from, both at the server side and at the client site. And, there are many open communication protocols which allow the server side and client side technology stocks to work together quite happily. Okay, let's now highlight the key benefits of the microservices architecture. Okay, so one of the key benefits is that microservices have shorter development times, because the system is split up into smaller moving parts. You can work on a moving part individually. You can have teams working on different parts concurrently, and because microservices are small in size, and they have a single focus, and the team have less to worry about in terms of scope, they know the one thing they're working on has a certain scope, and there's no need to worry about the entire system, as long as they honor the contracts between services. And because these services are loosely coupled, developers can rework, change, and deploy individual components, without deploying or affecting the entire system, and therefore deployment is more reliable and faster. Shorter development times and reliable and faster deployment also enable frequent updates. As we've already briefly mentioned, frequent updates can give you a competitive edge in the marketplace. The microservices architecture also allows us to decouple changeable parts. For example if we know, UI for our system, our user interface for our system changes quite often, if it uses the microservices architecture, the UI is most likely decoupled from all the services in the background, and therefore you can change it independently from all the services. Microservices architecture also increases security. In a monolithic system, you might have one central database, with one system accessing that database, and therefore all you need to do is hack that one system in order to gain access to the data. In the microservices architecture each microservice has its own database, and each microservice can also have its own security mechanism, therefore making the data distributed, and making the data even more secure. Microservices architecture also offers you increased uptime, because when it comes to upgrading the system, you will probably deploy one microservice at the time without affecting rest of the system. And because the system is split up into business domains and business functions, when a problem arises, we can probably quickly identify which service is responsible for that specific business function, and therefore resolve the problem within that microservice. Microservices architecture also make the system highly scalable, and it gives the system better performance. When there's a specific part of the system which is in demand, we can just scale that specific part up instead of scaling the whole system up. So if for example the inventory service is in demand, we can create many instances of that microservice without duplicating the entire system. We can also give the ownership of a microservice to a particular development team, so that there's better ownership and knowledge about the microservice. We've already briefly mentioned that microservices allow us to use the right technology for specific parts in the system. And because each microservice is separate from the other microservice, they don't share databases, and they have their own codebase, you can easily have microservices being worked on concurrently by distributed teams. In the next section of the module, we'll start looking at the design principles that enable microservices, and enable these benefits that we get from microservices.

![Microservices - Why now?](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices_Why_Now.png?raw=true)

![Microservices - Benefits](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Microservices_Benefits.png?raw=true)

