# Rest

Most of the time when we hear this term, the first thing that comes to mind is APIs, it's how we build APIs, and JSON, because that's what we get back from these APIs, and that's a pretty common thing to say as all we read and hear about are, well, RESTful APIs that return JSON. But, REST isn't just about building an API which consists of a few HTTP services that return JSON. It's much broader than that.

Rest stand for Representational state transfer and is intended to evoke an image of how a well-designed web application behaves, a network of web pages where the user progresses through an application by selecting links (state transitions), resulting in the next page (representing the next state of the application) being transferred to the user and rendered for their use.

- REST is an architectural style, not a standard - we use standards to implement it
- REST is protocol agnostic - JSON isn't a part of REST, but theoretically not even HTTP is a part of REST, and that's really theoretical.

Imagine you want to read your favorite newspaper online. You've opened your browser. That browser, that's an HTTP client. You point it to a URI. That's the unique resource identifier. It identifies where the resource lives. By doing that, the browser actually sends an HTTP request to that URI. The server then does some magic and sends an HTTP response message back to the browser. That HTTP response message contains a representation of the page you've navigated to.  In our example, that would probably be some HTML and CSS. The browser then interprets that resource representation and shows it. In other words, the browser, our HTTP client, has changed state. Now let's say we click a link in our browser to access a specific article on the newspaper side. That one is again identified by a URI. A new request message is sent to the server, and the server again sends back a representation of the page, the resource. The browser interprets it and changes state. In other words, the client changes state depending on the representation of the resource we're accessing. And that's representational state transfer, or REST.

## REST Constraints

REST is defined by 6 constraints (one optional).

A contraint is a design decision that can have positive and negative impacts - for this, contraints that benefits are considered to outweight the disadvantages.

- Client-server constraint - a very basic fundamental constraint. What this does is enforce client-server architecture. A client, or consumer of the API in our lingo, shouldn't be concerned with how data is stored, or how the representation is generated, that's transparent. A server, the API in our lingo, shouldn't be concerned with, for example, the user interface or user state or anything related to how the client is implemented. In other words, client and server can evolve separately.
- Statelessness constraint - this means that the necessary state to handle every request is contained within the request itself. When a client requests a resource, that request contains all the information necessary to service the request.  It's one of the constraints that ensures RESTful APIs can scale so easily. We don't have things like server-side session state to keep in mind when scaling up.
- Cacheable constraint - This one states that each response message must explicitly state if it can be cached or not. Like this we can eliminate some client/ server interaction, and at the same time prevent clients from using out-of-date data.
- Layered system constraint - That's a pretty easy one actually. A REST-based solution can be comprised of multiple architectural layers, just as almost all application architectures we use today. These layers can be modified, added, removed, but no one layer can directly access a layer that's beyond the next one. That also means that a client cannot tell whether it's directly connected to the final layer or to another intermediary along the way. REST restricts knowledge to a single layer, which reduces the overall system complexity.
- Optional code on demand constraint - This one states that the server can extend or customize client functionality. For example, if your client is a web application, the server can transfer JavaScript code to the client to extend its functionality.
- Uniform interface constraint - as it's divided into four sub-constraints. It states that the API and the consumers of the API share one single technical interface. As we're typically working with the HTTP protocol, this interface should be seen as a combination of resource URIs, where we can find resources, HTTP methods, how we can interact with them, like GET and POST, and HTTP media types, like application/json, application/xml, or more specific versions of that that are reflected in the request and response bodies. All of these are standards, by the way. This makes it is a good fit for cross-platform development. By describing such a contract, this uniform interface constraint decouples the architecture, which in turn enables each part to evolve independently. The four subconstraint are:
  
    1. Identification of resources - It states that individual resources are identified in requests using URIs, and those resources are conceptually separate from the representations that are returned to the client. The server doesn't send an entity from its database or possibly a combination of fields from multiple additional databases and services because our author resource doesn't necessarily map to an author in one database. Instead it sends the data, typically for RESTful APIs, as JSON, but HTML, XML, or custom formats are also possible.
    2. Manipulation of resources through representations - When a client holds a representation of a resource, including any possible metadata, it has enough information to modify or delete a resource on the server, provided it has permission to do so. If the API supports deleting the resource, the response could include, for example, the URI to the author resource, because that's what's required for deleting it.
    3. Self-descriptive message - Each message must include enough information on how to process it. When a consumer requests data from an API, we send a request message, but that message also has headers and a body. If the request body contains a JSON representation of a resource, the message must specify that fact in its headers by including the media type, application/json for example. Like that, the correct parser can be invoked to process the request body, and it can be serialized into the correct class. Same goes for the other way around. Mind you this application/json media type is a simple sample. Media types actually play a very important role in REST.
    4. HATEOS (Hypermedia as the Engine of Application State) - This is the one that a lot of RESTful systems fail to implement. Remember that example we had in the beginning of the module when we explained while looking at a newspaper site how the state of our browser changed when we clicked the link? Well, that link, that's hypertext. Hypermedia is a generalization of this. It adds other types like music, images, etc., and it's that hypermedia that should be the engine of application state. In other words, it drives how to consume and use the API. It tells the consumer what it can do with the API. Can I delete this resource? Can I update it? How can I create it, and where can I find it? This really boils down to a self-documenting API, and that documentation can then be used by the client application to provide functionality to the user.

![REST Constraints 1](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/REST_Constraints_1.png?raw=true)

![REST Constraints 2](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/REST_Constraints_2.png?raw=true)

A system is only considered RESTful when it adheres to all the required constraints.

Not all of these constraints are straightforward to implement, and to be completely correct, an architecture that skips on one of the required constraints or weakens it is considered not conformed to REST, and that immediately means that most APIs that are built today and are called RESTful, well, they aren't really RESTful.

It does mean that you need to know the consequences of deviating from these constraints and understand the potential tradeoff.

HTTP APIs come in many forms.  It's called the Richardson Maturity Model, and it'll help us position REST for building HTTP APIs better.

## The Richardson Maturity Model

The Richardson Maturity Model is a model developed by Leonard Richardson.

It grades, if you will, APIs by their RESTful maturity, so it's interesting to look into it as it shows us how we can go from a simple API that doesn't really care about protocol nor standards, to an API that can be considered RESTful.

- Level 0 - The Swamp of POX, or plain-old XML - This level states that the implementing protocol, HTTP, is used for remote interaction. But, we use it just as that and we don't use anything else from the HTTP protocol correctly. So for example, to get some altered data, you send over a POST request to some basic entry point URI, like host/myapi, and in the body you send some XML that contains info on the data you want. You then get back the data you asked for in the response. To create an author, you send another POST request with some data in the body to that same entry point, and so on. In other words, HTTP is used, but only as a transport protocol. And example of this is SOAP, or other typical remote procedure call implementations. It's not a fully correct statement, but you see a lot of these RPC style implementations when building services with Windows Communication Foundation.

![The Richardson Maturity Model Level 0](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/The_Richardson_Maturity_Model_Level_0.png?raw=true)

- Level 1 - Resources - From this moment on, multiple URIs are used and each URI is mapped to a specific resource, so it extends on level 0 where there was only 1 URI. For example, we now have a URI, host/api/authors, to get a list of authors, and another one, host/api/authors, followed by an ID, to get the author with that specific ID. However, only one method like POST is still used for all interactions. So, the HTTP methods aren't used as they should be according to the standards. This is already one little part of the uniform interface constraint we see here. From a software design point of view, this means reducing complexity by working with different endpoints instead of one large service endpoint.

![The Richardson Maturity Model Level 1](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/The_Richardson_Maturity_Model_Level_1.png?raw=true)

- Level 2 - Verbs - To reach a level 2 API, the correct HTTP verbs, like GET, POST, PUT, PATCH, and DELETE, are used as they are intended by the protocol. In the example we see a GET request to get a list of authors, and a POST request containing a resource representation in the body for creating an author. The correct status codes are also included in this level, i. e. use a 200 Ok after a successful GET, a 201 Created after a successful POST, and so on.  This again adds to that uniform interface constraint. From a software design point of view, we have just removed unnecessary variation. We're using the same verbs to handle the same types of situations.

![The Richardson Maturity Model Level 2](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/The_Richardson_Maturity_Model_Level_2.png?raw=true)

- Level 3 - Hypermedia controls - This means that the API supports HATEOAS, another part of that uniform interface constraint. A sample GET request to the authors resource would then return not only the list of authors, but also links, hypermedia, that drive application state. From a software design point of view, this means we've introduced discoverability, self-documentation. What is important to know is that according to Roy Fielding, who coined the term REST, a level 3 API is a precondition to be able to talk about a RESTful API. So, this maturity model does not mean there's such a thing as a level 1 RESTful API, a level 2 RESTful API, and so on. It means that there are APIs of different levels, and only when we reach level 3 we can start talking about a RESTful API.

![The Richardson Maturity Model Level 3](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/The_Richardson_Maturity_Model_Level_3.png?raw=true)

## Positioning ASP.NET Core for Building RESTful APIs

RESTful APIs can be built with a variety of technologies. We're going to use ASP. NET Core and the MVC middleware.

It's very important to know that we don't just get a RESTful API out of the box just because we're building an API with ASP. NET Core. That's our responsibility. We get that by adhering to the constraints.

The rest of the explanation is on the API file.

## Structuring Our Outer Facing Contract

The outer facing contract consists of three big concepts a consumer of an API uses to interact with that API.

- Resource Identifier - the URIs where the resources can be found
- HTTP methods
- Payload (OPTIONAL) - Representation - Media types

 When creating a resource, the HTTP response will contain a resource representation in its body. The format of those representations is what media types are used for, like application JSON. The uniform interface constraint does cover the fact that resources are identified by URIs. Each resource has its own URI, but as far as naming of resources is concerned, there isn't a standard that describes that, or at least not unless you want to dive into OData. There are, however, best practices for this. A resource name in a URI should always be a noun. In other words, a RESTful URI should refer to a resource that is a thing, instead of referring to an action.

 So we shouldn't create a getauthors resource, that's an action. We should create an authors resource, that's a thing conveyed by a noun, and use the GET method to get it. To get one specific author then, we'd append it with a forward slash and the authorId. Using these nouns conveys meaning, it describes the resource, so we shouldn't call a resource orders, when it's in fact about authors. That principle should be followed throughout the API for predictability. It helps a consumer understand the API structure.

![Resource Naming Guideline 1](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Resource_Naming_Guideline.png?raw=true)

 If we have another non-hierarchical resource, say employees, we shouldn't name it api/something/something/employees, we should name it api/employees. A single employee then shouldn't be named id/employees, it should be named employees, forward slash, and the employeeId. This helps keep the API contract predictable and consistent. There's quite a bit of a debate going on on whether or not we should pluralize these nouns. I prefer to pluralize them as it helps to convey meaning. When I see an authors resource, that tells us it's a collection of authors and not one author, but good APIs that don't pluralize nouns exist as well. If you prefer that you can, but do make sure to stay consistent. Either all resources should be pluralized nouns, or singular nouns, and not a mix.

![Resource Naming Guideline 2](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Resource_Naming_Guideline_2.png?raw=true)

 Another important thing you'd want to represent in an API contract is the hierarchy. Our data or models have structure. For example, an author has books that should be represented in the API contract. So if you want to define an author's books, where the books in the model hierarchy are children of an author, we should represent them as api/authors/authorId/books. A single book should then be followed by the bookId. APIs often expose additional capabilities like filtering and ordering resources, those parameters should be passed through the credit string, they aren't resources in their own right. So we shouldn't write something along the lines of api/authors/orderby/name. There's a few contract smells in that URI. A plural noun should be followed by an Id, and not by another word, and orderby isn't a noun, and a URI like this would mean we'd have defined three different resources - authors, authors/orderby, and authors/orderby/name. So api/authors followed by orderby=name in the credit string is a better fit.

![Resource Naming Guideline 3](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Resource_Naming_Guideline_3.png?raw=true)

But there is an exception. Sometimes there's these remote procedure calls, style-like calls, like calculate total, that don't easily map to resources. Most RPC-style like calls do map to resources, as we've just proven, but what if we need to calculate, say, the total amount of pages an author wrote? It's not that easy to create a resource from that using pluralized nouns. You'd end up with something like api/authors/authorId/pagetotals. We'd expect this to return a collection and not a number.

![Resource Naming Guideline 4](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Resource_Naming_Guideline_4.png?raw=true)

Api/authors/authorId/totalamountofpages. It isn't according to these best practices, but as long as it's an exceptional case, it doesn't mean you've suddenly got a bad API. Remember there isn't standards for following for these naming guidelines, these are just guidelines. So by following these simple rules we'll end up with a good resource URI design.

![Resource Naming Guideline 5](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Resource_Naming_Guideline_5.png?raw=true)

Talking about IDs. REST stops at that outer facing contract. The layers underneath, including the data store, are of no importance to REST, so getting an author might mean that you're actually fetching data from three different data stores, including some fields from Active Directory, to compose that author resource representation. So it's of no importance, our resource isn't the same as what is in the backend store. These are two different concepts. But from that follows the question, what should we use as identifiers? REST is unrelated to the backend data store, yet often you'll see APIs that actually use the auto-numbered primary key Ids from the database. If the backend doesn't matter, what happens to the resource URIs if you change the backend? The resource URI should remain the same, but if resources are identified by their database auto-numbered fields, and we switch out our current SQL Server to a backend that uses another type of auto-number sequence like MongoDB, all of a sudden all our resource Ids can change. We can, of course, work around that on migration, but still, it's a good idea to keep this in mind when designing resource URIs. And there's a solution for this. GUIDs, unique and unguessable values you can use as primary key in every database. From that we can then switch out datastore technologies and our resource URIs will stay the same. We're also no longer potentially exposing implementation details, as those GUIDs don't give anything away about the underlying technology. This advantage, in my book, is readability. As a developer it's not that convenient to type over a GUID to test an API call, but that's what testing tools are for, and for the end product it shouldn't matter. It's not users like you and me who tend to talk to an API, say for during development, its other pieces of code. And for those it really doesn't matter if the URI contains a hard-to-type GUID.

![Resource Naming Guideline 6](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Resource_Naming_Guideline_6.png?raw=true)

![Resource Naming Guideline 7](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Resource_Naming_Guideline_7.png?raw=true)

## Routing

Routing matches a request URI to an action on a controller. So once we send an HTTP request, the MVC framework parses the URI, and tries to map it to an action on a controller, and there's two ways it can do this, convention-based or attribute-based.

- Convetion-based - we have to configure these conventions. We can do that by passing in these routing conventions to the UseMvc extension method. This example would map the URI values index to an index method on a controller named values controller. As you can guess from that example, this is a typical sample of something that's used when building a web application with views that return HTML. The MVC Middleware can be used for that, but for APIs the ASP. NET Core team recommends not using convention-based routing, but attribute- based routing instead.

![Routing Guidelines 1](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Routing_Guidelines.png?raw=true)

- Attribute-based - as the name implies, allows us to use attributes at controller and action level. We provide these with a URI template, and through that template and the attribute itself, a request is matched to a specific action on a controller. For this we use a variety of attributes, depending on the HTTP method we want to match. We should not dinamically put the Route of the Controller as the controller name, because if we were to have a refactoring of our codes, and rename the controller class to URI, to our authors resource, would automatically change. For APIs this in not an advantage, resource URIs should remain the same, and if we were to refactor this controller so it has another name, all our resources URIs would change. The name of the underlying class is of no importance to the consumer, so that is something we want to avoid.

![Routing Guidelines 2](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Routing_Guidelines_2.png?raw=true)

## Interacting with Resources Through HTTP Methods

Different actions can happen to resources at the same URI. For example, getting an author and deleting an author are interactions with the same resource URI. It's the method that defines the action that will happen, and depending on the method, we'll potentially need to send or get a payload. It's important to follow this standard so other components of our application can rely on this being implemented correctly.

- GET - Reading Resources - There is no request payload, but the response payload contains either a list of author representations, or a single author.

- POST - Creating a resource - Payload we pass in is a representation of the resource we're going to create, an author in our example, and the response payload then contains the newly created author resource.

- PUT or PATCH - Ppdating resources - two options are available. The first one is PUT, which should be used for full updates. A PUT request to api/authors/authorId would update the author with that Id. The request payload is a representation of the resource we want to update, including all fields, and if a field is missing, it should be put to its default value. The response payload can be that updated author, or it can be empty, but you don't always want to fully update your resource, in fact, more often than not, you'll need partial updates to update only one or two fields instead of all of them. And that's what the PATCH method is for. The URI is the same as for PUT. The request payload is somewhat special here, it's a JsonPatchDocument, essentially a set of changes that should be executed on that resource. And just as with PUT, the response payload can be that updated author, or it can be empty.

- DELETE - Delete a resource - This time, both requests and response payloads are empty.

- HEAD - Is identical to GET with the notable difference that the API shouldn't return a response body, so no response payload. It can be used to obtain information on the resource like testing it for validity, for example, to test if a resource exists.

- OPTIONS - Represents a request for information about the communication options available on that URI. So in other words, OPTIONS will tell us whether or not we can GET the resource, POST it, DELETE it and so on. These OPTIONS are typically in the response headers and not in the body, so no response payload.

![HTTP Methods](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/HTTP_Methods.png?raw=true)

## Outer Facing Model vs Entity

Outer Facing Model != Business Model != Entity Model

When we designed the outer facing contract, we learned that REST stops at that level. What lies underneath that outer facing contract is of no importance to REST. From that we already know that the entity model, in our case used by Entity Framework Core, as a means to represent database roles as objects, should be different from the outer facing model. In some application architectures there's a business layer in-between, which in turn is different from the outer facing model and the entity model. The outer facing model does only represents the resources that are sent over the wire in a specific format, but it also leads to possibilities. 

Take an author, for example. We can see some pseudocode for that. An author is stored in our database with a DateOfBirth, but that DateOfBirth, well that might not be what we want to offer up to the consumers of the API. They might be better off with the age. Another example might be concatenation. Concatenating the FirstName and LastName from an entity into one name field in the resource representation, and sometimes data might come from different places. An author could have a field, say, Royalties, that comes from another API our API must interact with. That alone leads to issues when using entity classes for the outer facing contract, as they don't contain that field.

![Outer Facing Model VS Entity Model](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Outer_Facing_Model_VS_Entity_Model.png?raw=true)

Keeping these models separate leads to more robust, reliably evolvable code. Imagine having to change a database table, that would lead to a change of the Entity class. If we're using that same Entity class to directly expose data via the API, our clients might run into problems because they're not expecting an additional renamed or removed field. So when developing, it's fairly important to keep these separate.

NOTE: Attributes can also be used in other classes, like our DTOs (not only Entities), and they're very useful for validation scenarios, but the point here is that we won't implement these on the AuthorDto class, because this one is only used for one purpose, returning data. So using validation attributes or data annotations used to validate input doesn't make sense on this AuthorDto class, which is only used for returning data to the consumer.

## Handling Faults

Server errors.

We get back a 500 Internal Server Error. ASP. NET Core will automatically return this when an unhandled exception happens.

We might want to execute some additional logic when an exception happens, like logging a custom message or some information for the system admins.

There's a few ways we can handle these exceptions:

- Try-Catch - We want to make sure a 500 Internal server error is returned when something happens that results in our API not being able to fulfill the request, like our random exception we're throwing. So when we catch this exception, we return a status code 500. For that we can use the status code helper method. We pass in the status code and an optional message. That message, an object actually, will be serialized into the response body. What's important here is that we don't want to pass in the exception itself, let alone the stack trace. Passing in the stack trace and sending it to the consumer of the API means we would be exposing implementation details to that consumer, and that's a security risk, but it's also useless. The consumer of the API has no use for that stack trace, as this is a fault an exception is not responsible for, and can't do anything about. So we return a generic message or no message at all, as consumers of the API are often machines rather than humans. This means we'd essentially have to write try-catch statements for each action, and maybe logging statements. Moreover, even though we're in the development environment, we no longer see the developer-friendly error page. That's because we handled the exception when we called it by returning that 500 Internal Server Error. When running in production, you don't want to return a stack trace, but when you're developing it can be very useful. There's another option.
- Global Exception Handling - what we saw before we wrote a try-catch statement, well that is global exception handling at work. Let's open the Configure method in the Startup class. There's two pieces of middleware here that handle these exceptions, the exception handler middleware is used when we're in a production environment. An approach I like to take to handle faults when building a RESTful API is to let the developer exception page as-is during development. That said, when not running in a development environment, I like to add a bit of configuration to the exception handler middleware to have it return a generic error message. So this is the exception handler middleware, and we can configure that by passing in a lambda that returns an action on IApplicationBuilder. We can then call Run on that appBuilder. What that will do is add a piece of code, which we're going to write, to the request response pipeline. So what we want to do is make sure that the status code is 500, and that we write out a generic error message as the response body. So let's write a piece of code. We need an action on the context here, and on that context we use context. Response. StatusCode to set the status code, and then we write out our error message by calling into context. Response. WriteAsync. That one is from the Microsoft. AspNetCore. Http namespace. We pass in that same generic error message and we're done.

## Parent/Child Relationships

Then there's that author entity. We could add an AuthorDto here, letting AutoMapper take care of the mapping for us, but in this case that would result in the same AuthorDto being returned for each book. That's redundant information, and it will hurt performance sending it over the wire for each book.  If you had that same author again, and again, for each book, while the author possibly includes a collection of books, we will run into circular reference errors, so we do not include the author here. We can, however, safely include the AuthorId.

let's set this off against one of our constraints, manipulation of resources through representations. That's the constraint that's stated that when a client altered a presentation of a resource, including any possible metadata, it must have enough information to modify or delete a resource on the server, provided it has permission to do so. o if the consumer of the API gets the response we see now, does he have enough information to modify or delete the author? Well, not really, what should be in the response to allow for that, at a minimum, is the resource URI. We already include an Id, and often that's considered enough. From the Id a consumer can create a URI, but if you think about this a bit further, it isn't completely correct. An Id alone isn't what identifies the resource, it's the URI that identifies the resource, and the resource URI is part of the request, but it's not part of the response. So to adhere to this constraint we should include the URI in each representation if update or delete is allowed. It's just a matter of adding an extra field and filling it up with the URI, but it's also not completely correct, and we're just getting started. There's a much better way of handling this than including the URI, and that's through HATEOAS.

## Method Safety and Method Idempotency

A method is considered safe when it doesn't change to resource representation. For example, get and head are considered safe. Mind you that doesn't mean that other types of manipulation can't happen as a result of performing a get request. Behind the outer-facing contracts, the API might update a fields in related tables, but the resource representation itself shouldn't change, and if those side effects happen, these weren't requested by the consumer of the API.

A method is considered idempotent when it can be called multiple times with the same result. In other words, the side effects of calling it once are the same side effects that happen when calling it multiple times.

Get is both safe and idempotent. It doesn't change the resource representation, and when you call it multiple times, the same results are returned. Options and head follow the same logic, but post is none of these, it causes changes in resource representations because it creates them, and if we call post multiple times, multiple resources should be created. Delete isn't safe, the resource representation changes as the resource is deleted, but it is idempotent. Deleting the same resource multiple times has the same result as deleting it once. Put for full updates isn't safe either. If you update the resource, its representation might change, but it is idempotent. Updating the same resource multiple times results in the same representation as updating it once. And lastly, patch for partial updates is neither safe nor idempotent. We learned that through patch it's easy to, for example, add items to an array, which results in different representations if you do that multiple times, and this is not just some theory, it helps us decide what we are allowed to do for each method. We're building a RESTful API that uses these HTTP methods. It's a standard, so we should correctly implement it so other components we might use can rely on this being correctly implemented.

![Method Safety and Method Idempotency](https://github.com/andreborgesdev/Thesis-Notes/blob/master/Images/Method_Safety_&_Method_Idempotency.png?raw=true)

## Creating a Resource

We should create different DTOs for different operations.

Mind you there are system where the properties on the class used for output are exactly the same as those on the class used for input, but even in those cases, I'd suggest to keep these separate. It leads to a model that's more in line with the API functionality, make change already factoring afterwards much easier, and when validation comes into play, you typically want validation on input, but not necessarily on output. So I suggest to use a separate Dto for creating, updating, and returning resources.

he first thing we need to check is if the input provided in the request body was correctly serialized to AuthorForCreationDto. If that isn't the case, the author value will be null, that means the client made a mistake, so we return a 400 BadRequest. If that checks out, we can map the AuthorForCreationDto to an author entity, and add it to the database finder repository. So we'll have to create a new mapping first.

This is the first time we are adding an item to the database, so this might need some additional explanation. At this moment, the entity hasn't been added to the database yet, it's been added to the DbContext, which represents a session with the database. To persist our changes, we must call save on the repository, and if that's save fails, we should return a 500 internal server error. This save methods returns a Boolean, true or false, and we should see the repository has a bit of a black box. In essence, the controller doesn't know about the implementation, so it might contain exception handling code, it might not, it all depends on the provided implementation. So, I do like to treat it as a black box, but we do know what we want to return, a 500 internal server error with a generic error message. We only return a generic error message, because the consumer of the API really doesn't need to know what exactly went wrong, it just needs to know that it's not its responsibility. Our generic exception handler will not catch this, as save doesn't throw an exception, but we can use the StatusCode method for that, passing in the StatusCode. The StatusCode is 500, and we provide a generic message. But we already configured the exception handler middleware in the previous module to return a 500 internal server error with a generic message if an unhandled exception occurs. So another option is to throw an exception from the controller, and let the middleware handle it. Now is this a good approach or a bad approach? Well it's, it kind of depends. Throwing exceptions is expensive, it's a performance hit, so that would lead us to returning the StatusCode from the controller as a best practice, but on the other hand, that also means that we'll have code to return 500 internal server errors in different places, on the global level and in the controller itself. At this moment, that's not too much of a problem, but once we start implementing logging, that would also mean we'd want to provide logging code on each StatusCode 500 we return. I've seen both approaches, and there's something to be said for both. In this case, we're going to have the middleware handle all our responses that warrant a 500 internal server error. That'll come in nicely when we need to implement logging for these types of StatusCodes later on. We'll only have to write that code in one place, being at the configuration of the exception handler middleware.

In case of a successful post, we should return a 201 created response. For that, we can use the CreatedAtRoute method. This method allows us to return a response with the location header, and that location header, that will then contain the URI where the newly created author can be found. So the first thing we need to pass into this method is the route name that's going to be used for generating the URI. it should refer to the action to get a single author, that's our GetAuthor action. So, let's give this a name we can refer to, say GetAuthor, there we go. And we pass in GetAuthor as the first parameter of our CreatedAtRoute method. Now to get an author, we need the author ID. We need to pass that in as a route value, so the correct URI can be generated containing that ID. To do that, we pass in an anonymous type, and we give that anonymous type one field, ID, which is the name used in our route template, and we give it a value of authorToReturn. Id. And lastly, we want to pass in the actual authorToReturn Dto. This one will get serialized into the response body.

 Let's send it, we get back a 201 created, so that means that our author has been created again. We've now got two James Ellroy's in our database. Let's get that list of authors, and here we see that James Ellroy has been added to our database twice. So post is not idempotent, we cannot send that same request twice, and have the same result as only sending it once, because we now have two authors instead of just one. So now you've got a bit of unnecessary data in our database.
